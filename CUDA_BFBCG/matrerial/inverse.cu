// includes, system
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

/*Using updated (v2) interfaces to cublas*/
#include<cublas_v2.h>
#include<cuda_runtime.h>
#include<cusparse.h>
#include <cusolverDn.h>
#include<sys/time.h>


//Utilities
#include "includes/helper_debug.h"
// helper function CUDA error checking and initialization
#include "includes/helper_cuda.h"  
#include "includes/helper_functions.h"
#include "includes/cusolver_utils.h"

#define CHECK(call){ \
    const cudaError_t cuda_ret = call; \
    if(cuda_ret != cudaSuccess){ \
        printf("Error: %s:%d,  ", __FILE__, __LINE__ );\
        printf("code: %d, reason: %s \n", cuda_ret, cudaGetErrorString(cuda_ret));\
        exit(-1); \
    }\
}

/*
Compute inverse, X with LU factorization
A = LU
LU * X = I
L *(UX) = L * Y = I

Solve X
    UX = Y

*/

/*
mtxA =  |4 1|
        |1 3|

Answer
mtxA^(-1) = | 3/11 -1/11|
            |-1/11  4/11|

or

mtxA^(-1) = |0.2727  -0.091|
            |-0.091  0.3636|
*/




//Defince the dense matrix A column major
float mtxA[] = {4.0, 1.0, 1.0, 3.0};
float mtxI[] = {1.0, 0.0, 0.0, 1.0};

#define N 2




int main(int arg, char** argv){

    
    float *mtxA_d = nullptr;
    float *mtxAInv_d = nullptr; // solutoin matrix X such that A * x = I
    float *work_d = nullptr;

    //The devInfo pointer holds the status information after the LU decomposition or solve operations.
    int *devInfo = nullptr;
    
    /*
    A pivots_d pointer holds the pivot indices generated by the LU decomposition. 
    These indices indicate how the rows of the matrix were permuted during the factorization.
    */
    int *pivots_d = nullptr;
    
    //Status information specific to the LAPACK operations performed by cuSolver.
    // int *lapackInfo = nullptr;

    // Size of the workng space
    int lwork = 0;

    bool debug = true;

    //(1) Allocate device memeory
    CHECK(cudaMalloc((void**)&mtxA_d, N * N * sizeof(float)));
    CHECK(cudaMalloc((void**)&mtxAInv_d, N * N * sizeof(float)));
    CHECK(cudaMalloc((void**)&devInfo, sizeof(int)));
    CHECK(cudaMalloc((void**)&pivots_d, N * sizeof(int)));
    // CHECK(cudaMalloc((void**)&lapackInfo, sizeof(int)));


    //(2) Copy data to device
    CHECK(cudaMemcpy(mtxA_d, mtxA, N * N * sizeof(float), cudaMemcpyHostToDevice));
    
    //Store Identity matrix to matrix A inverse space to solve A * X = I
    //X will be overwriiten as A^{-1}
    CHECK(cudaMemcpy(mtxAInv_d, mtxI, N * N * sizeof(float), cudaMemcpyHostToDevice));



    //(3) Calculate work space
    cusolverDnHandle_t cusolverHandler;
    checkCudaErrors(cusolverDnCreate(&cusolverHandler));

    //Calculate work space for cusolver
    checkCudaErrors(cusolverDnSgetrf_bufferSize(cusolverHandler, N, N, mtxA_d, N, &lwork));
    checkCudaErrors(cudaMalloc((void**)&work_d, lwork * sizeof(float)));



    //(4) Perform the LU decomposition, 
    checkCudaErrors(cusolverDnSgetrf(cusolverHandler, N, N, mtxA_d, N, work_d, pivots_d, devInfo));
    cudaDeviceSynchronize();

    /*
    mtxA_d will be a compact form such that 

    A = LU = | 4  1 |
             | 1  3 |
    
    L = |1    0 |  U = |4    1  |
        |0.25 1 |      |0   2.75|
    
    mtxA_d compact form = | 4      1  |
                          | 0.25  2.75|
    */
    if(debug){
        printf("\n\nAfter LU factorization\n");
        printf("\n\n~~mtxA_d~~\n");
        print_mtx_clm_d(mtxA_d, N, N);
    }


    //Solve for the iverse, UX = Y
    /*
    A = LU
    A * X = LU * X = I
    L * (UX) = L * Y = I
    UX = Y
    */
    checkCudaErrors(cusolverDnSgetrs(cusolverHandler, CUBLAS_OP_N, N, N, mtxA_d, N, pivots_d, mtxAInv_d, N, devInfo));
    cudaDeviceSynchronize();


    if(debug){
        printf("\n\nCompute inverse\n");
        printf("\n\n~~mtxA inverse~~\n\n");
        print_mtx_clm_d(mtxA_d, N, N);
    }

    //(5) Free memory
    checkCudaErrors(cusolverDnDestroy(cusolverHandler));
    CHECK(cudaFree(mtxA_d));
    CHECK(cudaFree(mtxAInv_d));
    CHECK(cudaFree(work_d));
    CHECK(cudaFree(devInfo));
    CHECK(cudaFree(pivots_d));


    return 0;
}

/*
Sample Run

After LU factorization


~~mtxA_d~~
4.000000 1.000000 
0.250000 2.750000 


Compute inverse


~~mtxA inverse~~

4.000000 1.000000 
0.250000 2.750000 
*/